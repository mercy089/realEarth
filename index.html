<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Realistic 3D Earth Visualization</title>

  <style>
    /* === VIEWPORT RESPONSIVE SETUP === */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      /*       font-family: 'Segoe UI', 'Roboto', Arial, sans-serif; */
      background-color: #000;
      /* Ensure background is black */
    }

    @font-face {
      font-family: 'AbodeFont';
      /* You can name it anything */
      src: url('./font/Abode-Light.ttf') format('truetype');
    }

    /* Canvas takes full viewport space and is interactive */
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw !important;
      height: 100vh !important;
      cursor: grab;
      /* Indicate interactivity */
    }

    canvas:active {
      cursor: grabbing;
    }

    /* Responsive text labels that scale with viewport size */
    #labels {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: clamp(40px, 8vw, 80px);
      z-index: 10;
      pointer-events: none;
      letter-spacing: 3px;
      display: none;
      text-align: center;
      font-family: 'AbodeFont', sans-serif;
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
    }

    #labels::after {
      content: "पृथ्वीकुल";
      display: block;
      margin-left: clamp(50px, 15vw, 180px);
      margin-top: clamp(-15px, -2vw, -20px);
      color: rgb(255, 72, 0);
      font-size: clamp(30px, 6vw, 60px);
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="labels">
    Planetskool
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/objects/Lensflare.js"></script>

  <script>
    // === GLOBAL VARIABLES FOR 3D SCENE === //
    let scene, camera, renderer, earthMesh, cloudMesh, starMesh, controls, sunLight;

    function main() {
      const canvas = document.querySelector('#c');
      scene = new THREE.Scene();

      // === CAMERA SETUP === //
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 2;
      scene.add(camera);

      // === RENDERER SETUP === //
      renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        logarithmicDepthBuffer: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.autoClear = false;
      renderer.setClearColor(0x000000, 0.0);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // === HELPER FUNCTION TO CONVERT GITHUB BLOB URLS TO RAW URLS === //
      const toRawURL = (githubURL) => {
        if (!githubURL.includes('github.com')) return githubURL;
        const url = new URL(githubURL);
        url.hostname = 'raw.githubusercontent.com';
        url.pathname = url.pathname.replace('/blob/', '/');
        return url.href;
      };

      const textureLoader = new THREE.TextureLoader();

      // === EARTH GEOMETRY & MATERIAL === //
      const earthGeometry = new THREE.SphereGeometry(0.4, 64, 64);
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: textureLoader.load(toRawURL('https://github.com/mercy089/realEarth/blob/main/texture/world.jpg')),
        bumpMap: textureLoader.load(toRawURL('https://github.com/mercy089/realEarth/blob/main/texture/earthbump.jpg')),
        emissiveMap: textureLoader.load(toRawURL('https://github.com/mercy089/realEarth/blob/main/texture/8k_earth_nightmap.jpg')),
        emissive: new THREE.Color(0xffffff),
        emissiveIntensity: 1.0,
        bumpScale: 0.1, // Adjusted for more realism
        shininess: 5,
        specular: new THREE.Color(0x111111),
      });
      earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
      earthMesh.castShadow = true;
      earthMesh.receiveShadow = true;
      scene.add(earthMesh);

      // === LIGHTING SYSTEM === //
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);
      sunLight = new THREE.DirectionalLight(0xffffff, 1.5);

      // FIX: Set sun position based on real-world time
      function updateSunPosition() {
        const now = new Date();
        // Get the current time in UTC
        const utcHours = now.getUTCHours() + now.getUTCMinutes() / 60;

        // Calculate the day of the year
        const startOfYear = new Date(now.getFullYear(), 0, 0);
        const diff = now - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);

        // Calculate the sun's declination (latitude) based on the day of the year
        const declination = -23.45 * Math.cos(2 * Math.PI / 365 * (dayOfYear + 10));
        const sunLatRad = THREE.MathUtils.degToRad(declination);

        // Calculate the sun's longitude based on the UTC time
        const sunLongitude = (utcHours - 12) * 15;
        const sunLonRad = THREE.MathUtils.degToRad(sunLongitude);

        // Convert spherical coordinates (lat, lon) to Cartesian (x, y, z)
        const sunPosRadius = 5;
        sunLight.position.x = sunPosRadius * Math.cos(sunLatRad) * Math.cos(sunLonRad);
        sunLight.position.y = sunPosRadius * Math.sin(sunLatRad);
        sunLight.position.z = sunPosRadius * Math.cos(sunLatRad) * Math.sin(sunLonRad);
      }

      updateSunPosition(); // Set initial position

      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);

      // === CINEMATIC LENS FLARE === //
      const flareTexture0 = textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png");
      const flareTexture3 = textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare3.png");
      const lensflare = new THREE.Lensflare();
      lensflare.addElement(new THREE.LensflareElement(flareTexture0, 700, 0, sunLight.color));
      lensflare.addElement(new THREE.LensflareElement(flareTexture3, 60, 0.6));
      lensflare.addElement(new THREE.LensflareElement(flareTexture3, 70, 0.7));
      lensflare.addElement(new THREE.LensflareElement(flareTexture3, 120, 0.9));
      lensflare.addElement(new THREE.LensflareElement(flareTexture3, 70, 1.0));
      sunLight.add(lensflare);

      // === CLOUD LAYER === //
      const cloudGeometry = new THREE.SphereGeometry(0.405, 64, 64);
      const cloudMaterial = new THREE.MeshPhongMaterial({
        map: textureLoader.load(toRawURL('https://github.com/mercy089/realEarth/blob/main/texture/Earth-clouds.png')),
        transparent: true,
        opacity: 0.4,
        depthWrite: false,
        shininess: 80,
        specular: new THREE.Color(0x666666),
      });
      cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloudMesh.castShadow = true;
      scene.add(cloudMesh);

      // === STARFIELD BACKGROUND === //
      const starGeometry = new THREE.SphereGeometry(100, 64, 64);
      const starMaterial = new THREE.MeshBasicMaterial({
        map: textureLoader.load(toRawURL('https://github.com/mercy089/realEarth/blob/main/texture/HDR_multi_nebulae.jpg')),
        side: THREE.BackSide,
      });
      starMesh = new THREE.Mesh(starGeometry, starMaterial);
      scene.add(starMesh);

      // === ORBIT CONTROLS FOR INTERACTIVITY === //
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.screenSpacePanning = false;
      controls.minDistance = 1;
      controls.maxDistance = 4;
      controls.autoRotate = true;
      controls.autoRotateSpeed = -0.5;

      // === ANIMATION LOOP === //
      const animate = () => {
        requestAnimationFrame(animate);

        // The OrbitControls now handle the rotation
        cloudMesh.rotation.y += 0.0001;

        controls.update();
        starMesh.rotation.y -= 0.0002;
        renderer.render(scene, camera);
      };

      // === RESIZE HANDLER === //
      const handleResize = () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      };

      window.addEventListener('resize', handleResize);

      animate();
    }

    // === INITIALIZATION === //
    window.onload = () => {
      main();
      setTimeout(() => {
        document.getElementById('labels').style.display = 'block';
      }, 100);
    };
  </script>
</body>

</html>
