<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Realistic 3D Earth Visualization</title>

  <style>
    /* === VIEWPORT RESPONSIVE SETUP === */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      /*       font-family: 'Segoe UI', 'Roboto', Arial, sans-serif; */
      background-color: #000;
      /* Ensure background is black */
    }

    /* Canvas takes full viewport space and is interactive */
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw !important;
      height: 100vh !important;
      cursor: grab;
      /* Indicate interactivity */
    }

    canvas:active {
      cursor: grabbing;
    }

    /* Responsive text labels that scale with viewport size */
    #labels {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: clamp(40px, 8vw, 80px);
      z-index: 10;
      pointer-events: none;
      letter-spacing: 3px;
      display: none;
      text-align: center;
      font-family: 'Georgia', 'Times New Roman', serif; /* Fallback fonts until JS loads custom font */
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
      /* Remove CSS transition - will be handled by JavaScript */
    }

    #labels::after {
      content: "पृथ्वीकुल";
      display: block;
      margin-left: clamp(50px, 15vw, 180px);
      margin-top: clamp(-15px, -2vw, -20px);
      color: rgb(255, 72, 0);
      font-size: clamp(30px, 6vw, 60px);
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
    }

    /* Get Started Button - Glass Effect */
    #getStartedBtn {
      /* Fixed positioning - bottom right corner */
      position: fixed !important;
      bottom: 5% !important;
      right: 5% !important;
      top: auto !important;
      left: auto !important;
      transform: none !important;
      
      /* Glass morphism background */
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      
      /* Border and styling */
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50px;
      
      /* Text styling */
      color: white;
      font-size: clamp(16px, 3vw, 24px);
      font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
      font-weight: bold;
      padding: 15px 30px;
      
      /* Interactive elements */
      cursor: pointer;
      z-index: 20;
      pointer-events: auto;
      
      /* Glass effect shadows and glow */
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      
      /* Smooth transitions */
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      /* For pseudo-element positioning */
      overflow: hidden;
    }

    /* Glass button shine effect */
    #getStartedBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent
      );
      transition: left 0.5s;
    }

    #getStartedBtn:hover {
      /* Enhanced glass effect on hover */
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-3px);
      
      /* Enhanced glow */
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    #getStartedBtn:hover::before {
      left: 100%;
    }

    #getStartedBtn:active {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    /* Shifted states - removed since handled by JavaScript */

    /* Button stays in fixed position - no shifting */
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="labels">
    Planetskool
  </div>
  <button id="getStartedBtn">Get Started</button>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/objects/Lensflare.js"></script>

  <script>
    // === CONFIGURATION CONSTANTS === //
    const CONFIG = {
      CAMERA: {
        FOV: 50,
        NEAR: 0.1,
        FAR: 1000,
        INITIAL_Z: 2
      },
      EARTH: {
        RADIUS: 0.4,
        SEGMENTS: 64,
        ROTATION_SPEED: 0.001,
        GROUP_ROTATION_SPEED: 0.001
      },
      CLOUDS: {
        RADIUS: 0.405,
        SEGMENTS: 64,
        ROTATION_SPEED: 0.0005,
        OPACITY: 0.4
      },
      STARS: {
        RADIUS: 100,
        SEGMENTS: 64,
        ROTATION_SPEED_Y: -0.0002,
        ROTATION_SPEED_X: 0.0001
      },
      ANIMATION: {
        LERP_FACTOR: 0.05,
        SHIFT_DISTANCE: -1.0,
        TEXT_SHIFT_PERCENT: 25,
        CENTER_PERCENT: 50
      },
      URLS: {
        FONT: 'https://cdn.jsdelivr.net/gh/mercy089/realEarth@main/font/Abode-Light.ttf',
        TEXTURES: {
          EARTH: 'https://github.com/mercy089/realEarth/blob/main/texture/world.jpg',
          BUMP: 'https://github.com/mercy089/realEarth/blob/main/texture/earthbump.jpg',
          NIGHT: 'https://github.com/mercy089/realEarth/blob/main/texture/8k_earth_nightmap.jpg',
          CLOUDS: 'https://github.com/mercy089/realEarth/blob/main/texture/Earth-clouds.png',
          STARS: 'https://github.com/mercy089/realEarth/blob/main/texture/HDR_multi_nebulae.jpg'
        }
      }
    };

    // === FONT LOADING SYSTEM === //
    const FontLoader = {
      async load() {
        try {
          const font = new FontFace('AbodeFont', `url(${CONFIG.URLS.FONT})`, {
            style: 'normal',
            weight: '300',
            display: 'swap'
          });
          
          const loadedFont = await font.load();
          document.fonts.add(loadedFont);
          
          this.applyToElements();
          return true;
        } catch (error) {
          this.useFallback();
          return false;
        }
      },

      applyToElements() {
        const labelsElement = document.getElementById('labels');
        if (labelsElement) {
          labelsElement.style.fontFamily = "'AbodeFont', 'Georgia', 'Times New Roman', serif";
          this.forceRepaint(labelsElement);
        }
      },

      forceRepaint(element) {
        element.style.display = 'none';
        element.offsetHeight; // Trigger reflow
        element.style.display = 'block';
      },

      useFallback() {
        const labelsElement = document.getElementById('labels');
        if (labelsElement) {
          labelsElement.style.fontFamily = "'Georgia', 'Times New Roman', serif";
        }
      }
    };

    // === UTILITY FUNCTIONS === //
    const Utils = {
      toRawURL(githubURL) {
        if (!githubURL.includes('github.com')) return githubURL;
        const url = new URL(githubURL);
        url.hostname = 'raw.githubusercontent.com';
        url.pathname = url.pathname.replace('/blob/', '/');
        return url.href;
      },

      // Calculate responsive Earth radius based on screen size
      getResponsiveEarthRadius() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const minDimension = Math.min(screenWidth, screenHeight);
        
        // Base radius scaled by screen size
        // Mobile: 0.25-0.35, Tablet: 0.35-0.45, Desktop: 0.4-0.5
        if (minDimension < 480) {
          // Mobile phones
          return Math.max(0.25, Math.min(0.35, minDimension / 1400));
        } else if (minDimension < 768) {
          // Large phones / small tablets
          return Math.max(0.3, Math.min(0.4, minDimension / 1600));
        } else if (minDimension < 1024) {
          // Tablets
          return Math.max(0.35, Math.min(0.45, minDimension / 1800));
        } else {
          // Desktop
          return Math.max(0.4, Math.min(0.55, minDimension / 2000));
        }
      },

      // Calculate responsive cloud radius (slightly larger than Earth)
      getResponsiveCloudRadius() {
        return this.getResponsiveEarthRadius() + 0.005;
      },

      // Calculate responsive segments for geometry quality
      getResponsiveSegments() {
        const screenWidth = window.innerWidth;
        
        // Lower quality on smaller screens for better performance
        if (screenWidth < 480) {
          return 32; // Mobile - lower quality for performance
        } else if (screenWidth < 768) {
          return 48; // Large mobile - medium quality
        } else {
          return 64; // Desktop - high quality
        }
      },

      // Calculate responsive button size and positioning
      getResponsiveButtonStyles() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        if (screenWidth < 480) {
          // Mobile phones - larger touch targets
          return {
            fontSize: 'clamp(14px, 4vw, 18px)',
            padding: '12px 24px',
            bottom: '8%',
            right: '5%',
            borderRadius: '30px'
          };
        } else if (screenWidth < 768) {
          // Large phones/small tablets
          return {
            fontSize: 'clamp(16px, 3.5vw, 20px)',
            padding: '14px 28px',
            bottom: '6%',
            right: '5%',
            borderRadius: '40px'
          };
        } else if (screenWidth < 1024) {
          // Tablets
          return {
            fontSize: 'clamp(18px, 3vw, 22px)',
            padding: '15px 30px',
            bottom: '5%',
            right: '5%',
            borderRadius: '50px'
          };
        } else {
          // Desktop
          return {
            fontSize: 'clamp(16px, 3vw, 24px)',
            padding: '15px 30px',
            bottom: '5%',
            right: '5%',
            borderRadius: '50px'
          };
        }
      },

      // Calculate responsive text sizes
      getResponsiveTextStyles() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        if (screenWidth < 480) {
          // Mobile phones
          return {
            mainFont: 'clamp(28px, 7vw, 50px)',
            subFont: 'clamp(20px, 5vw, 35px)',
            letterSpacing: '2px',
            subMarginLeft: 'clamp(30px, 10vw, 120px)',
            subMarginTop: 'clamp(-10px, -1.5vw, -15px)'
          };
        } else if (screenWidth < 768) {
          // Large phones/small tablets
          return {
            mainFont: 'clamp(35px, 7.5vw, 60px)',
            subFont: 'clamp(25px, 5.5vw, 45px)',
            letterSpacing: '2.5px',
            subMarginLeft: 'clamp(40px, 12vw, 150px)',
            subMarginTop: 'clamp(-12px, -1.8vw, -18px)'
          };
        } else if (screenWidth < 1024) {
          // Tablets
          return {
            mainFont: 'clamp(40px, 8vw, 70px)',
            subFont: 'clamp(28px, 6vw, 55px)',
            letterSpacing: '3px',
            subMarginLeft: 'clamp(45px, 13vw, 160px)',
            subMarginTop: 'clamp(-15px, -2vw, -20px)'
          };
        } else {
          // Desktop
          return {
            mainFont: 'clamp(40px, 8vw, 80px)',
            subFont: 'clamp(30px, 6vw, 60px)',
            letterSpacing: '3px',
            subMarginLeft: 'clamp(50px, 15vw, 180px)',
            subMarginTop: 'clamp(-15px, -2vw, -20px)'
          };
        }
      },

      // Apply responsive styles to button
      updateButtonStyles() {
        const button = document.getElementById('getStartedBtn');
        if (!button) return;
        
        const styles = this.getResponsiveButtonStyles();
        
        button.style.fontSize = styles.fontSize;
        button.style.padding = styles.padding;
        button.style.bottom = styles.bottom;
        button.style.right = styles.right;
        button.style.borderRadius = styles.borderRadius;
      },

      // Apply responsive styles to text
      updateTextStyles() {
        const labels = document.getElementById('labels');
        if (!labels) return;
        
        const styles = this.getResponsiveTextStyles();
        
        labels.style.fontSize = styles.mainFont;
        labels.style.letterSpacing = styles.letterSpacing;
        
        // Update the pseudo-element styles dynamically
        const styleId = 'responsive-text-styles';
        let styleElement = document.getElementById(styleId);
        
        if (!styleElement) {
          styleElement = document.createElement('style');
          styleElement.id = styleId;
          document.head.appendChild(styleElement);
        }
        
        styleElement.textContent = `
          #labels::after {
            font-size: ${styles.subFont} !important;
            margin-left: ${styles.subMarginLeft} !important;
            margin-top: ${styles.subMarginTop} !important;
          }
        `;
      },

      calculateSunPosition() {
        const now = new Date();
        const utcHours = now.getUTCHours() + now.getUTCMinutes() / 60;
        const startOfYear = new Date(now.getFullYear(), 0, 0);
        const dayOfYear = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
        
        const declination = -23.45 * Math.cos(2 * Math.PI / 365 * (dayOfYear + 10));
        const sunLatRad = THREE.MathUtils.degToRad(declination);
        const sunLonRad = THREE.MathUtils.degToRad((utcHours - 12) * 15);
        
        const sunPosRadius = 5;
        return {
          x: sunPosRadius * Math.cos(sunLatRad) * Math.cos(sunLonRad),
          y: sunPosRadius * Math.sin(sunLatRad),
          z: sunPosRadius * Math.cos(sunLatRad) * Math.sin(sunLonRad)
        };
      }
    };

    // === 3D SCENE MANAGEMENT === //
    // === 3D SCENE MANAGEMENT === //
    class EarthScene {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.earthGroup = null;
        this.earthMesh = null;
        this.cloudMesh = null;
        this.starMesh = null;
        this.sunLight = null;
        this.textureLoader = new THREE.TextureLoader();
        
        // Animation state
        this.isShifted = false;
        this.targetX = 0;
        this.targetTextLeft = CONFIG.ANIMATION.CENTER_PERCENT;
        
        // Default positions for reset
        this.defaultCameraPosition = new THREE.Vector3(0, 0, CONFIG.CAMERA.INITIAL_Z);
        this.defaultCameraTarget = new THREE.Vector3(0, 0, 0);
      }

      init() {
        this.setupRenderer();
        this.setupCamera();
        this.setupScene();
        this.setupLighting();
        this.setupEarth();
        this.setupClouds();
        this.setupStars();
        this.setupControls();
        this.setupEventListeners();
        this.startAnimation();
      }

      setupRenderer() {
        const canvas = document.querySelector('#c');
        this.renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          logarithmicDepthBuffer: true,
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.autoClear = false;
        this.renderer.setClearColor(0x000000, 0.0);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      }

      setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
          CONFIG.CAMERA.FOV,
          window.innerWidth / window.innerHeight,
          CONFIG.CAMERA.NEAR,
          CONFIG.CAMERA.FAR
        );
        this.camera.position.z = CONFIG.CAMERA.INITIAL_Z;
      }

      setupScene() {
        this.scene = new THREE.Scene();
        this.scene.add(this.camera);
        
        // Create Earth group for positioning
        this.earthGroup = new THREE.Object3D();
        this.earthGroup.position.x = 0;
        this.scene.add(this.earthGroup);
      }

      setupLighting() {
        // Ambient lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        this.scene.add(ambientLight);
        
        // Sun light with real-world positioning
        this.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        this.updateSunPosition();
        this.sunLight.castShadow = true;
        this.sunLight.shadow.mapSize.width = 2048;
        this.sunLight.shadow.mapSize.height = 2048;
        this.scene.add(this.sunLight);
        
        // Lens flare effects
        this.setupLensFlare();
      }

      setupLensFlare() {
        const flareTexture0 = this.textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png");
        const flareTexture3 = this.textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare3.png");
        
        const lensflare = new THREE.Lensflare();
        lensflare.addElement(new THREE.LensflareElement(flareTexture0, 700, 0, this.sunLight.color));
        lensflare.addElement(new THREE.LensflareElement(flareTexture3, 60, 0.6));
        lensflare.addElement(new THREE.LensflareElement(flareTexture3, 70, 0.7));
        lensflare.addElement(new THREE.LensflareElement(flareTexture3, 120, 0.9));
        lensflare.addElement(new THREE.LensflareElement(flareTexture3, 70, 1.0));
        
        this.sunLight.add(lensflare);
      }

      setupEarth() {
        // Use responsive radius and segments
        const earthRadius = Utils.getResponsiveEarthRadius();
        const earthSegments = Utils.getResponsiveSegments();
        
        const earthGeometry = new THREE.SphereGeometry(earthRadius, earthSegments, earthSegments);
        const earthMaterial = new THREE.MeshPhongMaterial({
          map: this.textureLoader.load(Utils.toRawURL(CONFIG.URLS.TEXTURES.EARTH)),
          bumpMap: this.textureLoader.load(Utils.toRawURL(CONFIG.URLS.TEXTURES.BUMP)),
          emissiveMap: this.textureLoader.load(Utils.toRawURL(CONFIG.URLS.TEXTURES.NIGHT)),
          emissive: new THREE.Color(0xffffff),
          emissiveIntensity: 1.0,
          bumpScale: 0.1,
          shininess: 5,
          specular: new THREE.Color(0x111111),
        });
        
        this.earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        this.earthMesh.castShadow = true;
        this.earthMesh.receiveShadow = true;
        this.earthGroup.add(this.earthMesh);
      }

      setupClouds() {
        // Use responsive radius and segments
        const cloudRadius = Utils.getResponsiveCloudRadius();
        const cloudSegments = Utils.getResponsiveSegments();
        
        const cloudGeometry = new THREE.SphereGeometry(cloudRadius, cloudSegments, cloudSegments);
        const cloudMaterial = new THREE.MeshPhongMaterial({
          map: this.textureLoader.load(Utils.toRawURL(CONFIG.URLS.TEXTURES.CLOUDS)),
          transparent: true,
          opacity: CONFIG.CLOUDS.OPACITY,
          depthWrite: false,
          shininess: 80,
          specular: new THREE.Color(0x666666),
        });
        
        this.cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
        this.cloudMesh.castShadow = true;
        this.earthGroup.add(this.cloudMesh);
      }

      setupStars() {
        const starGeometry = new THREE.SphereGeometry(CONFIG.STARS.RADIUS, CONFIG.STARS.SEGMENTS, CONFIG.STARS.SEGMENTS);
        const starMaterial = new THREE.MeshBasicMaterial({
          map: this.textureLoader.load(Utils.toRawURL(CONFIG.URLS.TEXTURES.STARS)),
          side: THREE.BackSide,
        });
        
        this.starMesh = new THREE.Mesh(starGeometry, starMaterial);
        this.scene.add(this.starMesh);
      }

      setupControls() {
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.minDistance = 1;
        this.controls.maxDistance = 4;
        this.controls.autoRotate = false;
        this.controls.autoRotateSpeed = 0;
      }

      updateSunPosition() {
        const sunPos = Utils.calculateSunPosition();
        this.sunLight.position.set(sunPos.x, sunPos.y, sunPos.z);
      }

      setupEventListeners() {
        // Window resize
        window.addEventListener('resize', () => this.handleResize());
        
        // Button functionality
        const getStartedBtn = document.getElementById('getStartedBtn');
        getStartedBtn.addEventListener('click', () => this.toggleView());
      }

      handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Update Earth and cloud sizes on resize
        this.updateEarthSize();
      }

      updateEarthSize() {
        // Get new responsive sizes
        const newEarthRadius = Utils.getResponsiveEarthRadius();
        const newCloudRadius = Utils.getResponsiveCloudRadius();
        const newSegments = Utils.getResponsiveSegments();
        
        // Update Earth geometry
        if (this.earthMesh) {
          const earthGeometry = new THREE.SphereGeometry(newEarthRadius, newSegments, newSegments);
          this.earthMesh.geometry.dispose(); // Clean up old geometry
          this.earthMesh.geometry = earthGeometry;
        }
        
        // Update Cloud geometry
        if (this.cloudMesh) {
          const cloudGeometry = new THREE.SphereGeometry(newCloudRadius, newSegments, newSegments);
          this.cloudMesh.geometry.dispose(); // Clean up old geometry
          this.cloudMesh.geometry = cloudGeometry;
        }
        
        // Update UI elements
        Utils.updateButtonStyles();
        Utils.updateTextStyles();
      }

      toggleView() {
        const getStartedBtn = document.getElementById('getStartedBtn');
        const labelsElement = document.getElementById('labels');
        
        if (!this.isShifted) {
          // Switch to presentation view
          this.camera.position.set(0, 0, CONFIG.CAMERA.INITIAL_Z);
          this.controls.target.set(0, 0, 0);
          this.controls.update();
          
          this.targetX = CONFIG.ANIMATION.SHIFT_DISTANCE;
          this.targetTextLeft = CONFIG.ANIMATION.TEXT_SHIFT_PERCENT;
          
          getStartedBtn.textContent = 'Back';
          document.body.classList.add('shifted');
          this.controls.enabled = false;
          this.isShifted = true;
        } else {
          // Return to center view
          this.targetX = 0;
          this.targetTextLeft = CONFIG.ANIMATION.CENTER_PERCENT;
          
          this.camera.position.copy(this.defaultCameraPosition);
          this.controls.target.copy(this.defaultCameraTarget);
          this.controls.update();
          
          this.controls.enabled = true;
          getStartedBtn.textContent = 'Get Started';
          document.body.classList.remove('shifted');
          this.isShifted = false;
        }
      }

      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          this.update();
          this.render();
        };
        animate();
      }

      update() {
        const labelsElement = document.getElementById('labels');
        
        // Smooth position animations
        this.earthGroup.position.x += (this.targetX - this.earthGroup.position.x) * CONFIG.ANIMATION.LERP_FACTOR;
        
        // Smooth text position animation
        if (labelsElement) {
          const currentTextLeft = parseFloat(labelsElement.style.left || CONFIG.ANIMATION.CENTER_PERCENT);
          const newTextLeft = currentTextLeft + (this.targetTextLeft - currentTextLeft) * CONFIG.ANIMATION.LERP_FACTOR;
          labelsElement.style.left = newTextLeft + '%';
        }
        
        // Rotation animations
        this.earthGroup.rotation.y += CONFIG.EARTH.GROUP_ROTATION_SPEED;
        this.earthMesh.rotation.y += CONFIG.EARTH.ROTATION_SPEED;
        this.cloudMesh.rotation.y += CONFIG.CLOUDS.ROTATION_SPEED;
        this.starMesh.rotation.y += CONFIG.STARS.ROTATION_SPEED_Y;
        this.starMesh.rotation.x += CONFIG.STARS.ROTATION_SPEED_X;
        
        this.controls.update();
      }

      render() {
        this.renderer.render(this.scene, this.camera);
      }
    }

    // === APPLICATION INITIALIZATION === //
    class App {
      constructor() {
        this.earthScene = new EarthScene();
      }

      async init() {
        try {
          // Load custom font
          await FontLoader.load();
          
          // Initialize 3D scene
          this.earthScene.init();
          
          // Show UI elements
          this.showUI();
          
        } catch (error) {
          // Application initialization failed - continue with fallbacks
        }
      }

      showUI() {
        setTimeout(() => {
          const labelsElement = document.getElementById('labels');
          if (labelsElement) {
            labelsElement.style.display = 'block';
          }
          
          // Apply initial responsive styles
          Utils.updateButtonStyles();
          Utils.updateTextStyles();
        }, 100);
      }
    }

    // === MAIN ENTRY POINT === //
    window.onload = () => {
      const app = new App();
      app.init();
    };
  </script>
</body>

</html>
